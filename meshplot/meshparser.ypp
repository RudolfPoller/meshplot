/*
 *  meshparser.ypp
 *
 *  Created on: Apr. 12th, 2021
 *      Author: Dr. Rudolf Poller
 *
 *  Synopsis
 *  	bison grammar definition file for processing FE mesh data
 *
 *	bison version: 3.0.4
 *
 */
 
%require "3.0.4"
%language "c++"

%define parse.trace

%define api.value.type variant
%define api.token.constructor

%{

#include "meshplot.h"
#include "Point.h"
#include "Polygon.h"

typedef pair<NodeSet, ElemSet> FEMesh;
typedef pair<serial, Point*> LabPointP;

extern FEMesh *p_mesh;

GLfloat coords[3];
list<LabPointP> corners;

%}

%token				NODESET_BEGIN ELEMSET_BEGIN SET_END
%token	<serial>	LABEL
%token	<GLfloat>	COORD
%token				EOLN
%token				CHAR

%code {

using parser = yy::parser;
using symbol_type = parser::symbol_type;

symbol_type yylex(void);

}

%%

list:				%empty
					| list mesh
					| list EOLN
					| list error EOLN
					
mesh:				nodeset eofs elemset

eofs:				%empty
					| eofs  EOLN

nodeset:			NODESET_BEGIN node_block SET_END
					
node_block:			node
					| node_block node
					
node:				LABEL coordinates EOLN
						{ p_mesh->first[$1] = Point(coords[0], coords[1], coords[2]); }

coordinates:		COORD COORD
						{ coords[0] = $1; coords[1] = $2; coords[2] = 0.0f; }
					| COORD COORD COORD
						{ coords[0] = $1; coords[1] = $2; coords[2] = $3; }

elemset:			ELEMSET_BEGIN corner_block SET_END

corner_block:		elem
					| corner_block elem

elem:				LABEL corners EOLN
						{ p_mesh->second[$1] = Polygon(corners);
						  corners.clear(); }

corners:			LABEL LABEL LABEL additional_nodes
						{ corners.push_front(LabPointP($3, &p_mesh->first[$3]));
						  corners.push_front(LabPointP($2, &p_mesh->first[$2]));
						  corners.push_front(LabPointP($1, &p_mesh->first[$1])); }

additional_nodes:	%empty
					| additional_nodes LABEL
						{ corners.push_back(LabPointP($2, &p_mesh->first[$2])); }

%%

#include <FlexLexer.h>
#include "parsescan.h"

#define LEXDEBUG	0

class MeshScanner meshlexer;

symbol_type yylex(void) {
	meshlexer.set_debug(LEXDEBUG);
	return meshlexer.yylex(0);
}

void parser::error(const string& msg) {
	cerr << msg << " near line " << meshlexer.lineno();
	cerr << " at token " << meshlexer.YYText() << endl;
	exit(1);
}

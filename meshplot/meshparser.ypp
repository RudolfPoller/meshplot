/*
 *  meshparser.ypp
 *
 *  Created on: Apr. 12th, 2021
 *      Author: Dr. Rudolf Poller
 *
 *  Synopsis
 *  	bison grammar definition file for processing FE mesh data
 *
 *	bison version: 3.7
 *
 */
 
%require "3.7"
%language "c++"

%define parse.trace

%define api.value.type variant
%define api.token.constructor

%{

using namespace std;

#include <vector>

#include "meshplot.h"
#include "Point.h"
#include "Polygon.h"

typedef pair<NodeSet, ElemSet> FEMesh;

extern FEMesh *p_mesh;

const int LexDebug = 0;

static int				cix;
static GLfloat 			coords[3];
static vector<serial>	labels;
static list<LabPointP> 	corners;

%}

%token				NODESET_BEGIN ELEMSET_BEGIN SET_END
%token	<serial>	POSINT
%token	<GLfloat>	REALNUM
%token				ZERO
%token				EOLN

%code {

yy::parser::symbol_type yylex(void);

}

%%

list:				%empty
					| list mesh
					| list EOLN
					| list error EOLN
					
mesh:				nodeset eofs elemset

eofs:				%empty
					| eofs  EOLN

nodeset:			NODESET_BEGIN node_block SET_END
					
node_block:			node
					| node_block node
					
node:				label coordinates EOLN
						{
						  p_mesh->first[labels[0]]
							= Point(coords[0], coords[1], coords[2]);
						  cix = 0;
						  labels.clear();
						}

coordinates:		coord coord
						{ coords[2] = 0.0f; }
					| coord coord coord

elemset:			ELEMSET_BEGIN element_block SET_END

element_block:		element
					| element_block element

element:			label nodelabs EOLN
						{
						  p_mesh->second[labels[0]] = Polygon(corners);
						  corners.clear();
						  labels.clear();
						}

nodelabs:			label label label add_nodelabs
						{
						  serial l;
						  l = labels[3];
						  corners.push_front(
						  		LabPointP(l, &p_mesh->first[l])
						  );
						  l = labels[2];
						  corners.push_front(
						  		LabPointP(l, &p_mesh->first[l])
						  );
						  l = labels[1];
						  corners.push_front(
						  		LabPointP(l, &p_mesh->first[l])
						  );
						}

add_nodelabs:		%empty
					| add_nodelabs label
						{
						  serial l = labels.back();
						  corners.push_back(LabPointP(l, &p_mesh->first[l]));
						}
						
label:				POSINT
						{ labels.push_back($1); }

coord:				ZERO
						{ coords[cix++] = 0.0f; }
					| REALNUM
						{ coords[cix++] = $1; }
					| POSINT
						{ coords[cix++] = static_cast<GLfloat>($1); }

%%

#include <FlexLexer.h>
#include "parsescan.h"

class MeshScanner meshlexer;

yy::parser::symbol_type yylex(void) {
	meshlexer.set_debug(LexDebug);
	return meshlexer.yylex(0);
}

void yy::parser::error(const string& msg) {
	cerr << msg << " near line " << meshlexer.lineno();
	cerr << " at token " << meshlexer.YYText() << endl;
	exit(1);
}
